// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Sigma ALgo

//@version=5
indicator(title = "SIGMA HEIKIN ASHI DRAGON V2 ",overlay=true, max_bars_back=541)
import Avventuriero/MMDonLib/12 as MMDon
import Avventuriero/SessionInBoxesPro/5 as SessInBoxes

//UTILITY FUNCS
//{

getCurrentLabel(value, location, prefix, newline, col, isUp) =>
    var label l = na
    var line li = na
    //labelSize = lbSize == 0 ? size.auto : lbSize == 1 ? size.tiny : lbSize == 2 ? size.small : lbSize == 3 ? size.normal : lbSize == 4 ? size.large : size.huge
    labelSize = size.normal
    lineSize = labelSize
    if na(l)
        textV = newline ? prefix + " " + str.tostring(value, "#.####") : prefix + " = " + str.tostring(value, "#.####")
        l := label.new(bar_index+100, location, style = label.style_none, text = textV, size = labelSize, color = #00000000, textcolor = col)
    if not na(l)
        label.delete(l)
        textV = newline ? prefix + " " + str.tostring(value, "#.####") : prefix + " = " + str.tostring(value, "#.####")
        l := label.new(bar_index+100, location, style = label.style_none, text = textV, size = labelSize, color = #00000000, textcolor = col)
    if na(li)
        li:=line.new(extend = extend.none, x1=bar_index+10, y1=location, x2=bar_index+180, y2=location, xloc=xloc.bar_index, color = col, style = line.style_solid, width = 1 )
    if not na(li)
        line.delete(li)
        li:=line.new(x1=bar_index+10, y1=location, x2=bar_index+180, y2=location, xloc=xloc.bar_index, extend = extend.none, color = col, style = line.style_solid, width = 1 )
    if na(value)
        line.delete(li)
        label.delete(l)
    if not na(value) and bar_index > 5
        label.set_xloc(l, bar_index+100, xloc.bar_index)
        
            
        textV = newline ? prefix + " " + str.tostring(value, "#.####") : prefix + " = " + str.tostring(value, "#.####")
        
        label.set_y(l, location)
        label.set_text(l, textV)
        //label.set_style(l, isUp ? label.style_label_up : label.style_label_down)
        label.set_color(l, #00000000)
round_pips(pips_unrounded) =>
    float atr = 0
    if (syminfo.type == "forex")
        atr   := pips_unrounded / syminfo.mintick / 10
    else // other instrument
        atr   := pips_unrounded
    atr

round_price(x) =>
    xx = int(x / syminfo.mintick)
    xx * syminfo.mintick    
//}

showCalculator = input.bool(true,title="Show ATR risk Calculator", group="Device Settings", inline = "dvsett")
mobileDevice = input.string("Desktop",title="Calculator Size",  options = ['Desktop','Mobile'], group="Device Settings", inline = "dvsett")

//MM SETTINGS
//{
g_mm = "money management settings"
accountSize = input.int(title="Account Size", defval=1000, minval=1, step=1, group = g_mm, inline = "mm1")
percentRisk = input.float(title="Percent Risk", defval=2, minval=0, step=0.01, group = g_mm, inline = "mm1")
// i_sl = input.string("ATR", "SL Rule", options=["ATR", "//", "///"],group = g_mm, inline="mmsl")
//i_sl="ATR"
Atrlen=input.int(15,title="SL ATR Length",group = g_mm, inline="mm3")
Atrmul = input.float(title="SL Mult", defval=2, minval=0, step=0.1, group = g_mm, inline = "mm3")

enableTP2 = input.bool(false, title="TP2", inline="mmtp", group=g_mm)
enableTP3 = input.bool(false, title="TP3", inline="mmtp", group=g_mm)
//enableRunner = input.bool(false, title="Runner", inline="mmtp", group=g_mm)
enableRunner = false
tp1x = input.float(1.0,step=0.1,title='RR: TP1',group = g_mm, inline = "mm2")
tp2x = input.float(2.0,step=0.1,title='TP2',group = g_mm, inline = "mm2")
tp3x = input.float(3.0,step=0.1,title='TP3',group = g_mm, inline = "mm2")

BE = input.string("NO BE", title = "BE", options = ["BE after TP1","BE after TP2", "NO BE"], inline = "mm4", group = g_mm )
BEoff = input.int(0, title = "BE offset", inline = "mm4", group = g_mm )
isTPscale = input.bool(false, title = "Move SL with TP", inline = "mm4", group = g_mm )
//CompoundingSignals = input.bool(false, title="Compounding Signals",group = g_mm) 
showSignals = input.bool(true, title="Show Signals",group = g_mm)
//}

//TABLE VARS
//{
moneyToRiskPerTrade = accountSize*(percentRisk/100)    
ATR = round_pips(ta.atr(Atrlen))
stoplossInPips = ATR*Atrmul
Lot_Size = moneyToRiskPerTrade/stoplossInPips/10
//}

//STRICT ENTRIES SETTINGS
//{
g_ses = "STRICT ENTRIES SETTINGS"    
hc_strict = input.bool(true, "Heikin Ashi MA1 Strict", group = g_ses, inline = "-hcc2")
hc_strict_t = input.string("Close", "| Trigger", options=["Close", "H/L"], group = g_ses, inline = "-hcc2" )
hc_strict2 = input.bool(false, "Heikin Ashi MA2 Strict", group = g_ses, inline = ",-hcc2")
hc_strict_t2 = input.string("Close", "| Trigger", options=["Close", "H/L"], group = g_ses, inline = ",-hcc2" )
tl_strict = input.bool(false, "Baseline Strict", group = g_ses, inline = "-tl" )
atrs_strict = input.bool(false, "ATR Band Strict", group = g_ses, inline = "atrsm" )
//hmtf_strict = input.bool(false, "Heiken Ashi MTF Strict", group = g_ses, inline = "-hcmtf" )
hmtf_strict_t = input.string("Close", "MTF HC Trigger", options=["Close", "H/L"], group = g_ses, inline = "-hcmtf" )
hmtf2 = input.bool(false, "HC TF2", group = g_ses, inline="hcmtfs")
hmtf3 = input.bool(false, "HC TF3", group = g_ses, inline="hcmtfs")
hmtf4 = input.bool(false, "HC TF4 <- Strict", group = g_ses, inline="hcmtfs")
conf_c = input.bool(false, "Confirmation Candle", group = g_ses)
exit_cond = input.string("NO EXIT COND.", "Exit Condition", options=["NO EXIT COND.", "HEIKIN ASHI OPPOSITE CANDLE", "TRADITIONAL BASELINE", "HEIKIN ASHI BASELINE","ATR BAND STOP"], group = g_ses)
//}

//HEIKEN CANDLES SETTINGS
//{
g_hcsett="HEIKIN ASHI MA1 SETTINGS"

shc = input.bool(true, "Show", group = g_hcsett, inline = "-hcc")  
shcw = input.bool(true, "Show Wicks", group = g_hcsett, inline = "-hcc")  
//candleType = input.string(title ="Candle Type", defval="Keikō Ashi", options=["None","Smoothed Heinin Ashi","Keikō Ashi"], group =g_hcsett)
deflen = input.string("SWING", "Mode", options=["SWING", "SCALP"], tooltip="SCALP:10\nSWING:22\nOtherwise you can adjust the lenght enabling the option Adjust Lenght", group = g_hcsett, inline="--")
enlen = input.bool(false, "Adjust Lenght", group = g_hcsett, inline="--")
_len3= input.int(21,title='', group = g_hcsett, inline="--")

len3 = enlen?_len3:(deflen=="SWING"?21:10)

source= input.source(close, group = g_hcsett, inline="hcc")
//hullma = ta.wma(2*ta.wma( source, len3/2)-ta.wma(source, len3), math.round(math.sqrt(len3)))
tipi = input.string("HullMA",title="Style", options=["SMA","EMA","WMA","HullMA","VWMA","RMA"], group = g_hcsett, inline="hcc") //1=SMA, 2=EMA, 3=WMA, 4=HullMA, 5=VWMA, 6=RMA
media1 = tipi == "SMA" ? ta.sma(source,len3) : tipi == "EMA" ? ta.ema(source,len3) : tipi == "WMA" ? ta.wma(source,len3) : tipi == "HullMA" ? ta.hma(source, len3) : tipi == "VWMA" ? ta.vwma(source, len3) : tipi == "RMA" ? ta.rma(source,len3) : na

source2= input.source(open, group = g_hcsett, inline="hco")
//hullma2 = wma(2*wma(source2, len3/2)-wma(source2, len3), round(sqrt(len3)))
tipi2 = input.string("HullMA",title="Style", options=["SMA","EMA","WMA","HullMA","VWMA","RMA"], group = g_hcsett, inline="hco")
media2 = tipi2 == "SMA" ? ta.sma(source2,len3) : tipi2 == "EMA" ? ta.ema(source2,len3) : tipi2 == "WMA" ? ta.wma(source2,len3) : tipi2 == "HullMA" ? ta.hma(source2, len3) : tipi2 == "VWMA" ? ta.vwma(source2, len3) : tipi2 == "RMA" ? ta.rma(source2,len3) : na

source3= input(high, group = g_hcsett, inline="hch")
//hullma3 = wma(2*wma(source3, len3/2)-wma(source3, len3), round(sqrt(len3)))
tipi3 = input.string("HullMA",title="Style", options=["SMA","EMA","WMA","HullMA","VWMA","RMA"], group = g_hcsett, inline="hch")
media3 = tipi3 == "SMA" ? ta.sma(source3,len3) : tipi3 == "EMA" ? ta.ema(source3,len3) : tipi3 == "WMA" ? ta.wma(source3,len3) : tipi3 == "HullMA" ? ta.hma(source3, len3) : tipi3 == "VWMA" ? ta.vwma(source3, len3) : tipi3 == "RMA" ? ta.rma(source3,len3) : na

source4= input(low, group = g_hcsett, inline="hcl")
//hullma4 = wma(2*wma(source4, len3/2)-wma(source4, len3), round(sqrt(len3)))
tipi4 = input.string("HullMA",title="Style", options=["SMA","EMA","WMA","HullMA","VWMA","RMA"], group = g_hcsett, inline="hcl")
media4 = tipi4 == "SMA" ? ta.sma(source4,len3) : tipi4 == "EMA" ? ta.ema(source4,len3) : tipi4 == "WMA" ? ta.wma(source4,len3) : tipi4 == "HullMA" ? ta.hma(source4, len3) : tipi4 == "VWMA" ? ta.vwma(source4, len3) : tipi4 == "RMA" ? ta.rma(source4,len3) : na
//}

//HEIKEN CANDLES SETTINGS
//{
g_hcsett2="HEIKEN ASHI MA2 SETTINGS"

_shc = input.bool(true, "Show", group = g_hcsett2, inline = ",-hcc")  
_shcw = input.bool(false, "Show Wicks", group = g_hcsett2, inline = ",-hcc")  
//candleType = input.string(title ="Candle Type", defval="Keikō Ashi", options=["None","Smoothed Heinin Ashi","Keikō Ashi"], group =g_hcsett2)
_deflen = input.string("SWING", "Mode", options=["SWING", "SCALP"], tooltip="SCALP:10\nSWING:22\nOtherwise you can adjust the lenght enabling the option Adjust Lenght", group = g_hcsett2, inline=",--")
_enlen = input.bool(true, "Adjust Lenght", group = g_hcsett2, inline=",--")
__len3= input.int(100,title='', group = g_hcsett2, inline=",--")

len32 = _enlen?__len3:(_deflen=="SWING"?21:10)

_source= input.source(close, group = g_hcsett2, inline=",hcc")
//hullma = ta.wma(2*ta.wma( source, len3/2)-ta.wma(source, len3), math.round(math.sqrt(len3)))
_tipi = input.string("HullMA",title="Style", options=["SMA","EMA","WMA","HullMA","VWMA","RMA"], group = g_hcsett2, inline=",hcc") //1=SMA, 2=EMA, 3=WMA, 4=HullMA, 5=VWMA, 6=RMA
_media1 = tipi == "SMA" ? ta.sma(source,len32) : tipi == "EMA" ? ta.ema(source,len32) : tipi == "WMA" ? ta.wma(source,len32) : tipi == "HullMA" ? ta.hma(source, len32) : tipi == "VWMA" ? ta.vwma(source, len32) : tipi == "RMA" ? ta.rma(source,len32) : na

_source2= input.source(open, group = g_hcsett2, inline=",hco")
//hullma2 = wma(2*wma(source2, len32/2)-wma(source2, len32), round(sqrt(len32)))
_tipi2 = input.string("HullMA",title="Style", options=["SMA","EMA","WMA","HullMA","VWMA","RMA"], group = g_hcsett2, inline=",hco")
_media2 = tipi2 == "SMA" ? ta.sma(source2,len32) : tipi2 == "EMA" ? ta.ema(source2,len32) : tipi2 == "WMA" ? ta.wma(source2,len32) : tipi2 == "HullMA" ? ta.hma(source2, len32) : tipi2 == "VWMA" ? ta.vwma(source2, len32) : tipi2 == "RMA" ? ta.rma(source2,len32) : na

_source3= input(high, group = g_hcsett2, inline=",hch")
//hullma3 = wma(2*wma(source3, len32/2)-wma(source3, len32), round(sqrt(len32)))
_tipi3 = input.string("HullMA",title="Style", options=["SMA","EMA","WMA","HullMA","VWMA","RMA"], group = g_hcsett2, inline=",hch")
_media3 = tipi3 == "SMA" ? ta.sma(source3,len32) : tipi3 == "EMA" ? ta.ema(source3,len32) : tipi3 == "WMA" ? ta.wma(source3,len32) : tipi3 == "HullMA" ? ta.hma(source3, len32) : tipi3 == "VWMA" ? ta.vwma(source3, len32) : tipi3 == "RMA" ? ta.rma(source3,len32) : na

_source4= input(low, group = g_hcsett2, inline=",hcl")
//hullma4 = wma(2*wma(source4, len32/2)-wma(source4, len32), round(sqrt(len32)))
_tipi4 = input.string("HullMA",title="Style", options=["SMA","EMA","WMA","HullMA","VWMA","RMA"], group = g_hcsett2, inline=",hcl")
_media4 = tipi4 == "SMA" ? ta.sma(source4,len32) : tipi4 == "EMA" ? ta.ema(source4,len32) : tipi4 == "WMA" ? ta.wma(source4,len32) : tipi4 == "HullMA" ? ta.hma(source4, len32) : tipi4 == "VWMA" ? ta.vwma(source4, len32) : tipi4 == "RMA" ? ta.rma(source4,len32) : na
//}

//TRENDLINE SETTINGS
//{
g_tlsett="BASELINE SETTINGS"

show_ma = input.bool(false, title='Show Baseline', group=g_tlsett, inline="tl")
malen = input.int(100, title="Baseline Length", group=g_tlsett, inline="tl")
tltype = input.string(defval="ALMA", options=["SMA","EMA","DEMA","TEMA","LSMA","WMA","TMA","HMA", "JMA", "Kijun v2", "EDSMA","McGinley", "ALMA", "SSL", "MMMA"], title="Baseline Type", group=g_tlsett, inline="tl1")
tlsrc = input.source(close, title="Baseline Source", group=g_tlsett, inline="tl1")
kidiv = input.int(defval = 1,maxval=4,  title="Kijun MOD Divider", group=g_tlsett, inline="tl2")
jurik_power = input.int(title = "JMA Power", defval=1, group=g_tlsett, inline="tl2")
Thicknes = input.int(8,"Thickness", group=g_tlsett, inline="tl0")
Transparency = input.int(50, "Transparency", group=g_tlsett, inline="tl0")
//}

//ATR STOP MASTER SETTINGS
//{
g_atrsm = "ATR BAND SETTINGS"
dintval = input.timeframe("60", title = "| Timeframe", group = g_atrsm, inline = "atrsm")
useIntval = input.bool(false, title = "Always Use Current Chart", group = g_atrsm, inline = "atrsm2")
useHeikin = input.bool(false, title = "Use Heikin-Ashi Bars", tooltip = "Source will be ohlc4", group = g_atrsm, inline = "atrsm2")
atrLen = input.int(14, title = "ATR Lenght", minval = 1, maxval = 100, group = g_atrsm)
m1 = input.float(3.5, title = "ATR Multiplier: ADX Rising", minval = 0.1, step = 0.1, maxval = 100, group = g_atrsm, inline = "atrsm1")
m2 = input.float(1.75, title = "ADX Falling", minval = 0.1, step = 0.1, maxval = 100, group = g_atrsm, inline = "atrsm1")
adxLen = input.int(14, title = "ADX", minval = 1, maxval = 100, group = g_atrsm, inline = "atrsm8")
adxThresh = input.int(25, title = "ADX Threshold", minval = 1, group = g_atrsm, inline = "atrsm8")

// aboveThresh = input(true, title = "ADX Above Threshold uses ATR Falling Multiplier Even if Rising?")
aboveThresh = true


textColor = input.color(title = "Text Color", defval = #FFFFFFFF, group = g_atrsm, inline = "atrsm3")
labelColorPos = input.color(title = "Label Color - Bullish", defval = color.aqua, group = g_atrsm, inline = "atrsm3")
labelColorNeg = input.color(title = "Bearish", defval = color.red, group = g_atrsm, inline = "atrsm3")
size = input.int(2, title = "Label Size (0 = Auto, 1 - 5)", minval = 0, maxval = 5, group = g_atrsm, inline = "atrsm5")
offset = input.int(0, title = "Label Offset", minval = 0, maxval = 1000, group = g_atrsm, inline = "atrsm5")
bandHalfWidth = input.int(0, title = "Band Pip/Tick Size Around Stop (0 = off)", minval = 0, group = g_atrsm)
bandColorPos = input.color(title = "Band Color - Bullish", defval  =color.aqua, group = g_atrsm, inline = "atrsm4")
bandColorNeg = input.color(title = "Bearish", defval = color.red, group = g_atrsm, inline = "atrsm4")



showPrice = input.bool(true, "Show Stop Price Values", group = g_atrsm, inline = "atrsm6")
showSessType = input.bool(true, "Show Session Type", group = g_atrsm, inline = "atrsm6")
showLast = input.bool(false, "Show Only Current ATR Stop Value", group = g_atrsm, inline = "atrsm7")
        
//}

//HEIKEN CANDLES MTF SETTINGS
//{
g_hmtf = "HEIKIN CANDLES MTF SETTINGS"

    
hmtf2res = input.timeframe("", "HC TF2", group = g_hmtf, inline="hcmtf2")
phmtf2 = input.bool(false, "Show", group = g_hmtf, inline="-hcmtf2")
shcw2 = input.bool(false, "Show Wicks", group = g_hmtf, inline="-hcmtf2")

    
hmtf3res = input.timeframe("", "HC TF3", group = g_hmtf, inline="hcmtf3")
phmtf3 = input.bool(false, "Show", group = g_hmtf, inline="-hcmtf3")
shcw3 = input.bool(false, "Show Wicks", group = g_hmtf, inline="-hcmtf3")

    
hmtf4res = input.timeframe("", "HC TF4", group = g_hmtf, inline="hcmtf4")
phmtf4 = input.bool(false, "Show", group = g_hmtf, inline="-hcmtf4")
shcw4 = input.bool(false, "Show Wicks", group = g_hmtf, inline="-hcmtf4")

//}

//SESSIONS PRO SETTINGS
//{
g_sess_disp = "Session Display"
bool SHOW = timeframe.isintraday and timeframe.multiplier <= 60 and timeframe.multiplier >= 1
int LOOKBACKMINS = (9 * 60)
// Timezone
i_tz = input.string('America/Los_Angeles', title='Timezone', options=["America/Los_Angeles", "America/New_York","America/El_Salvador","America/Chicago","America/Argentina/Buenos_Aires","Europe/London","Europe/Berlin","Europe/Moscow","Asia/Dubai","Asia/Ashkhabad","Asia/Bangkok","Asia/Hong_Kong","Asia/Tokyo","Australia/Brisbane","Australia/Sydney"], group=g_sess_disp, tooltip = "Make sure your chart timezone matches with the option selected to have reliable sessions identification.")
i_show_history = input.string("YES", 'History', options=["YES", "NO"], group=g_sess_disp) == "YES"

// Sessions
g_lon="LONDON"
i_show_sess1 = input.bool(false, 'Show London', group=g_lon, inline="ss1") and SHOW
i_sess1 = input.session('0400-1300', 'Session Time', group=g_lon, inline="ss1")
strictLon = input.bool(false, title="Strict Entries", inline="LD-T", group=g_lon)
strictLonOR = input.bool(false, title="Opening Range Strict Entries", inline="LD-T", group=g_lon)

g_ny="NEW YORK"
i_show_sess2 = input.bool(false, 'Show New York', group=g_ny, inline="ss2") and SHOW
i_sess2 = input.session('0900-1700', 'Session Time', group=g_ny, inline="ss2")
strictNy = input.bool(false, title="Strict Entries", inline="NY-T", group=g_ny)
strictNyOR = input.bool(false, title="Opening Range Strict Entries", inline="NY-T", group=g_ny)

g_tok="TOKYO"
i_show_sess3 = input.bool(false, 'Show Tokyo', group=g_tok, inline="ss3") and SHOW
i_sess3 = input.session('2000-0200', 'Session Time', group=g_tok, inline="ss3")
strictTok = input(false, title="Strict Entries", inline="TK-T", group=g_tok)
strictTokOR = input(false, title="Opening Range Strict Entries", inline="TK-T", group=g_tok)

g_ber="BERLIN"
i_show_sess4 = input.bool(false, 'Show Berlin', group=g_ber, inline="ss4") and SHOW
i_sess4 = input.session('0200-1000', 'Session Time', group=g_ber, inline="ss4")
strictbl = input.bool(false, title="Strict Entries", inline="BL-T", group=g_ber)
strictblOR = input.bool(false, title="Opening Range Strict Entries", inline="BL-T", group=g_ber)

g_sid="SYDNEY"
i_show_sess5 = input.bool(false, 'Show Sydney', group=g_sid, inline="ss5") and SHOW
i_sess5 = input.session('0200-1000', 'Session Time', group=g_sid, inline="ss5")
strictSyd = input.bool(false, title="Strict Entries", inline="SD-T", group=g_sid)
strictSydOR = input.bool(false, title="Opening Range Strict Entries", inline="SD-T", group=g_sid)

g_sof = "SESSION OTHER FEATURES"
i_sess_extend = input.string("NO", 'Extend', inline="SOF", options=["NO", 'Extend + End line', 'Extend'], group=g_sof)
i_sess_fib = input.string("NO", 'Fibonacci Lines', inline="SOF", group=g_sof, options=["YES", "NO"], tooltip='Experimental feature') != "NO"
i_sess_op = input.string("NO", 'Opening Range', inline="SOF", group=g_sof, options=["YES", "NO"]) != "NO" and SHOW


g4 = "Sessions Boxes Show & Styles"
// Show & Styles
i_sess_border_style = input.string("Solid", 'Sessions Line style', options=["Solid", "Dot", "Dash"], group=g4)
i_sess_border_width = input.int(1, 'Sessions Line width', minval=1, group=g4)
i_sess_bgopacity = input.int(94, 'Sessions Background opacity', minval=0, maxval=100, step=1, group=g4, tooltip='Setting the 100 is no background color')
i_show_closed = input.string("NO", 'Sessions Closed icon', options=["YES", "NO"], group=g4) == "YES"

// Labels
i_label_show = input.bool(true, 'Labels', group=g4) and SHOW
i_label_size = input.string(size.normal, 'Labels Size', options=[size.auto, size.tiny, size.small, size.normal, size.large, size.huge], group=g4)
i_label_position = input.string('Inside', 'Position', options=['Inside', 'Outside'], group=g4) == 'Inside' ? label.style_label_upper_left : label.style_label_lower_left
i_label_chg = input.string("NO", "Labels Change value", options=["NO", "YES", "YESPIP"], group=g4)

// Opening Range
i_o_minutes = input.int(15, title='OR Lookback (minutes)', minval=1, step=1, tooltip='Minutes', group=g4)
i_o_opacity = input.int(84, title='OR Background opacity', minval=0, maxval=100, step=1, group=g4)

// Fibonacci lines
i_f_linestyle = input.string("Dash", title="FIB Line style", options=["Solid", "Dot", "Dash"], group=g4)
i_f_linewidth = input.int(1, title="FIB Line width", minval=1, group=g4)

RECT_LINESTYLE = i_sess_border_style == "Solid"?line.style_solid:(i_sess_border_style == "Dot"?line.style_dotted:line.style_dashed)
FIB_LINESTYLE = i_f_linestyle == "Solid"?line.style_solid:(i_f_linestyle == "Dot"?line.style_dotted:line.style_dashed)
string tz = (i_tz == "NO" or i_tz == '') ? na : i_tz
//}

//ALERTS SETTINGS
//{
long_alert = input.bool(true,title="BUY ALERTS", inline="10",group="Enable Alerts Settings")
short_alert = input.bool(true,title="SELL ALERTS", inline="11",group="Enable Alerts Settings")
tp1_alert = input.bool(true,title="TP1 ALERTS", inline="12",group="Enable Alerts Settings")
tp2_alert = input.bool(true,title="TP2 ALERTS", inline="13",group="Enable Alerts Settings")
tp3_alert = input.bool(true,title="TP3 ALERTS", inline="14",group="Enable Alerts Settings")
stop_alert = input.bool(true,title="STOP ALERTS", inline="15",group="Enable Alerts Settings")
breakeven_alert = input.bool(true,title="BREAKEVEN ALERTS", inline="16",group="Enable Alerts Settings")
sltotp1_alert = input.bool(true,title="SL TO TP1 ALERTS", inline="16",group="Enable Alerts Settings")
//}


//User has to agree to have the indi loading on the chart.
var user_consensus = input.string(defval="", title="TYPE 'agree' TO ADD TO CHART. \nTrading involves a risk of loss, and may not be appropriate for every one. Please consider carefully if trading is appropriate for you. Past performance is not indicative of future results. Any and all indicator signals provided by 'MM HEIKIN ASHI DRAGON V2' are for educational purposes only. Is your responsibility knowing that by typing 'agree' you are accepting that the AI would trade on your behalf at your own risk. \nRELEASE INFORMATION 2021 © Money Moves Investments", confirm = true, group="consensus")
var icc = false
if user_consensus == "agree"
    icc := true
else
    icc := false
    
//HEIKEN CANDLES
//{
// ——————————————————————————————————————————————————————————————————————————————————————————————————————
// ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
// PpSignal Haiken Ashi
// ——————————————————————————————————————————————————————————————————————————————————————————————————————
// ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
// Keikō Ashi = Trend Candle
// _open = ohlc4 > media1 ? ohlc4 : media1
// _close = ohlc4 > media1 ? media1 : ohlc4
// _high = high
// _low = low

//haiken ashi len 1
o= media2
c= media1
h= media3
l= media4

haclose = (o+h+l+c)/4
haopen = 0.0
haopen := na(haopen[1]) ? (o + c)/2 : (haopen[1] + haclose[1]) / 2
hahigh = math.max (h, math.max(haopen,haclose))
halow = math.min (l, math.min(haopen,haclose))

o2 = ta.wma(haopen, 6)
c2 = ta.wma(haclose, 6)
h2 = ta.wma(hahigh, 6)
ll2 = ta.wma(halow, 6)

// ——————————————————————————————————————————————————————————————————————————————————————————————————————
// ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
// plot candle     "None"

__open = o2 
__high = h2 
__low = ll2
__close = c2 

_bodyColor =  (__close > __open ? color.rgb(56,74,87, 40) : color.rgb(100, 27, 12, 0))// ohlc4 > media1 ? #00FFFF : #FFA500
_wickcolor = shcw?(__close > __open ? #00FFFF : #FFA500):color.new(color.black,100)// ohlc4 > Keltma ? #00FFFF : #FFA500

plotcandle(open=icc and shc?__open:na, high=icc and shc?__high:na, low=icc and shc?__low:na, close=icc and shc?__close:na, title="Candle", color=_bodyColor, wickcolor=_wickcolor)

//}

//HEIKEN CANDLES 2
//{
// ——————————————————————————————————————————————————————————————————————————————————————————————————————
// ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
// PpSignal Haiken Ashi
// ——————————————————————————————————————————————————————————————————————————————————————————————————————
// ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
// Keikō Ashi = Trend Candle
// _open = ohlc4 > media1 ? ohlc4 : media1
// _close = ohlc4 > media1 ? media1 : ohlc4
// _high = high
// _low = low

//haiken ashi len 1
_o= _media2
_c= _media1
_h= _media3
_l= _media4

_haclose = (_o+_h+_l+_c)/4
_haopen = 0.0
_haopen := na(_haopen[1]) ? (_o + _c)/2 : (_haopen[1] + _haclose[1]) / 2
_hahigh = math.max (_h, math.max(_haopen,_haclose))
_halow = math.min (_l, math.min(_haopen,_haclose))

_o2 = ta.wma(_haopen, 6)
_c2 = ta.wma(_haclose, 6)
_h2 = ta.wma(_hahigh, 6)
_ll2 = ta.wma(_halow, 6)

// ——————————————————————————————————————————————————————————————————————————————————————————————————————
// ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
// plot candle     "None"

___open = _o2 
___high = _h2 
___low = _ll2
___close = _c2 

__bodyColor =  (___close > ___open ? color.rgb(56,74,87, 40) : color.rgb(100, 27, 12, 0))// ohlc4 > media1 ? #00FFFF : #FFA500
__wickcolor = _shcw?(___close > ___open ? #00FFFF : #FFA500):color.new(color.black,100)// ohlc4 > Keltma ? #00FFFF : #FFA500

plotcandle(open=icc and _shc?___open:na, high=icc and _shc?___high:na, low=icc and _shc?___low:na, close=icc and _shc?___close:na, title="Candle", color=__bodyColor, wickcolor=__wickcolor)

//}


//HEIKEN CANDLES MTF
//{

[srctf2,src2tf2, src3tf2, src4tf2, ohlc4tf2, htf2, ltf2]  = request.security(syminfo.tickerid, hmtf2res, [source, source2, source3, source4, ohlc4, high, low])
[srctf3,src2tf3, src3tf3, src4tf3, ohlc4tf3, htf3, ltf3]  = request.security(syminfo.tickerid, hmtf3res, [source, source2, source3, source4, ohlc4, high, low])
[srctf4,src2tf4, src3tf4, src4tf4, ohlc4tf4, htf4, ltf4]  = request.security(syminfo.tickerid, hmtf4res, [source, source2, source3, source4, ohlc4, high, low])

tf2media1 = tipi == "SMA" ? ta.sma(srctf2,len3) : tipi == "EMA" ? ta.ema(srctf2,len3) : tipi == "WMA" ? ta.wma(srctf2,len3) : tipi == "HullMA" ? ta.hma(srctf2, len3) : tipi == "VWMA" ? ta.vwma(srctf2, len3) : tipi == "RMA" ? ta.rma(srctf2,len3) : na
tf2media2 = tipi2 == "SMA" ? ta.sma(src2tf2,len3) : tipi2 == "EMA" ? ta.ema(src2tf2,len3) : tipi2 == "WMA" ? ta.wma(src2tf2,len3) : tipi2 == "HullMA" ? ta.hma(src2tf2, len3) : tipi2 == "VWMA" ? ta.vwma(src2tf2, len3) : tipi2 == "RMA" ? ta.rma(src2tf2,len3) : na
tf2media3 = tipi3 == "SMA" ? ta.sma(src3tf2,len3) : tipi3 == "EMA" ? ta.ema(src3tf2,len3) : tipi3 == "WMA" ? ta.wma(src3tf2,len3) : tipi3 == "HullMA" ? ta.hma(src3tf2, len3) : tipi3 == "VWMA" ? ta.vwma(src3tf2, len3) : tipi3 == "RMA" ? ta.rma(src3tf2,len3) : na
tf2media4 = tipi4 == "SMA" ? ta.sma(src4tf2,len3) : tipi4 == "EMA" ? ta.ema(src4tf2,len3) : tipi4 == "WMA" ? ta.wma(src4tf2,len3) : tipi4 == "HullMA" ? ta.hma(src4tf2, len3) : tipi4 == "VWMA" ? ta.vwma(src4tf2, len3) : tipi4 == "RMA" ? ta.rma(src4tf2,len3) :na

tf3media1 = tipi == "SMA" ? ta.sma(srctf3,len3) : tipi == "EMA" ? ta.ema(srctf3,len3) : tipi == "WMA" ? ta.wma(srctf3,len3) : tipi == "HullMA" ? ta.hma(srctf3, len3) : tipi == "VWMA" ? ta.vwma(srctf3, len3) : tipi == "RMA" ? ta.rma(srctf3,len3) : na
tf3media2 = tipi2 == "SMA" ? ta.sma(src2tf3,len3) : tipi2 == "EMA" ? ta.ema(src2tf3,len3) : tipi2 == "WMA" ? ta.wma(src2tf3,len3) : tipi2 == "HullMA" ? ta.hma(src2tf3, len3) : tipi2 == "VWMA" ? ta.vwma(src2tf3, len3) : tipi2 == "RMA" ? ta.rma(src2tf3,len3) : na
tf3media3 = tipi3 == "SMA" ? ta.sma(src3tf3,len3) : tipi3 == "EMA" ? ta.ema(src3tf3,len3) : tipi3 == "WMA" ? ta.wma(src3tf3,len3) : tipi3 == "HullMA" ? ta.hma(src3tf3, len3) : tipi3 == "VWMA" ? ta.vwma(src3tf3, len3) : tipi3 == "RMA" ? ta.rma(src3tf3,len3) : na
tf3media4 = tipi4 == "SMA" ? ta.sma(src4tf3,len3) : tipi4 == "EMA" ? ta.ema(src4tf3,len3) : tipi4 == "WMA" ? ta.wma(src4tf3,len3) : tipi4 == "HullMA" ? ta.hma(src4tf3, len3) : tipi4 == "VWMA" ? ta.vwma(src4tf3, len3) : tipi4 == "RMA" ? ta.rma(src4tf3,len3) :na

tf4media1 = tipi == "SMA" ? ta.sma(srctf4,len3) : tipi == "EMA" ? ta.ema(srctf4,len3) : tipi == "WMA" ? ta.wma(srctf4,len3) : tipi == "HullMA" ? ta.hma(srctf4, len3) : tipi == "VWMA" ? ta.vwma(srctf4, len3) : tipi == "RMA" ? ta.rma(srctf4,len3) : na
tf4media2 = tipi2 == "SMA" ? ta.sma(src2tf4,len3) : tipi2 == "EMA" ? ta.ema(src2tf4,len3) : tipi2 == "WMA" ? ta.wma(src2tf4,len3) : tipi2 == "HullMA" ? ta.hma(src2tf4, len3) : tipi2 == "VWMA" ? ta.vwma(src2tf4, len3) : tipi2 == "RMA" ? ta.rma(src2tf4,len3) : na
tf4media3 = tipi3 == "SMA" ? ta.sma(src3tf4,len3) : tipi3 == "EMA" ? ta.ema(src3tf4,len3) : tipi3 == "WMA" ? ta.wma(src3tf4,len3) : tipi3 == "HullMA" ? ta.hma(src3tf4, len3) : tipi3 == "VWMA" ? ta.vwma(src3tf4, len3) : tipi3 == "RMA" ? ta.rma(src3tf4,len3) : na
tf4media4 = tipi4 == "SMA" ? ta.sma(src4tf4,len3) : tipi4 == "EMA" ? ta.ema(src4tf4,len3) : tipi4 == "WMA" ? ta.wma(src4tf4,len3) : tipi4 == "HullMA" ? ta.hma(src4tf4, len3) : tipi4 == "VWMA" ? ta.vwma(src4tf4, len3) : tipi4 == "RMA" ? ta.rma(src4tf4,len3) :na

//TF2
//{
// tf2_open = ohlc4tf2 > tf2media1 ? ohlc4tf2 : tf2media1
// tf2_close = ohlc4tf2 > tf2media1 ? tf2media1 : ohlc4tf2
// tf2_high = htf2
// tf2_low = ltf2

tf2o= tf2media2
tf2c= tf2media1
tf2h= tf2media3
tf2l= tf2media4

tf2haclose = (tf2o+tf2h+tf2l+tf2c)/4
tf2haopen = 0.0
tf2haopen := na(tf2haopen[1]) ? (tf2o + tf2c)/2 : (tf2haopen[1] + tf2haclose[1]) / 2
tf2hahigh = math.max (tf2h, math.max(tf2haopen,tf2haclose))
tf2halow = math.min (tf2l, math.min(tf2haopen,tf2haclose))

tf2o2 = ta.wma(tf2haopen, 6)
tf2c2 = ta.wma(tf2haclose, 6)
tf2h2 = ta.wma(tf2hahigh, 6)
tf2ll2 = ta.wma(tf2halow, 6)

// ——————————————————————————————————————————————————————————————————————————————————————————————————————
// ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
// plot candle     "None"

tf2__open = tf2o2 
tf2__high = tf2h2 
tf2__low = tf2ll2
tf2__close = tf2c2 

tf2_bodyColor = (tf2__close > tf2__open ? color.rgb(56,74,87, 40) : color.rgb(100, 27, 12, 0))// ohlc4 > media1 ? #00FFFF : #FFA500
tf2_wickcolor = shcw2?(tf2__close > tf2__open ? #00FFFF : #FFA500):color.new(color.black,100) // ohlc4 > Keltma ? #00FFFF : #FFA500

plotcandle(open=icc and hmtf2 and phmtf2?tf2__open:na, high=icc and hmtf2 and phmtf2?tf2__high:na, low=icc and hmtf2 and phmtf2?tf2__low:na, close=icc and hmtf2 and phmtf2?tf2__close:na, title="Candle", color=tf2_bodyColor, wickcolor=tf2_wickcolor)
getCurrentLabel(icc and hmtf2 and phmtf2?tf2__close:na,tf2__close,"HC TF2(" + hmtf2res + ")",false, tf2_bodyColor, false)  
//}

//TF3
//{
// tf3_open = ohlc4tf3 > tf3media1 ? ohlc4tf3 : tf3media1
// tf3_close = ohlc4tf3 > tf3media1 ? tf3media1 : ohlc4tf3
// tf3_high = htf3
// tf3_low = ltf3

tf3o= tf3media2
tf3c= tf3media1
tf3h= tf3media3
tf3l= tf3media4

tf3haclose = (tf3o+tf3h+tf3l+tf3c)/4
tf3haopen = 0.0
tf3haopen := na(tf3haopen[1]) ? (tf3o + tf3c)/2 : (tf3haopen[1] + tf3haclose[1]) / 2
tf3hahigh = math.max (tf3h, math.max(tf3haopen,tf3haclose))
tf3halow = math.min (tf3l, math.min(tf3haopen,tf3haclose))

tf3o2 = ta.wma(tf3haopen, 6)
tf3c2 = ta.wma(tf3haclose, 6)
tf3h2 = ta.wma(tf3hahigh, 6)
tf3ll2 = ta.wma(tf3halow, 6)

// ——————————————————————————————————————————————————————————————————————————————————————————————————————
// ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
// plot candle     "None"

tf3__open = tf3o2 
tf3__high = tf3h2 
tf3__low = tf3ll2
tf3__close = tf3c2 

tf3_bodyColor = (tf3__close > tf3__open ? color.rgb(56,74,87, 40) : color.rgb(100, 27, 12, 0)) // ohlc4 > media1 ? #00FFFF : #FFA500
tf3_wickcolor = shcw3?(tf3__close > tf3__open ? #00FFFF : #FFA500):color.new(color.black,100)// ohlc4 > Keltma ? #00FFFF : #FFA500

plotcandle(open=icc and hmtf3 and phmtf3?tf3__open:na, high=icc and hmtf3 and phmtf3?tf3__high:na, low=icc and hmtf3 and phmtf3?tf3__low:na, close=icc and hmtf3 and phmtf3?tf3__close:na, title="Candle", color=tf3_bodyColor, wickcolor=tf3_wickcolor)
getCurrentLabel(icc and hmtf3 and phmtf3?tf3__close:na,tf3__close,"HC TF3(" + hmtf3res + ")",false, tf3_bodyColor, false) 
//}

//TF4
//{
// tf4_open = ohlc4tf4 > tf4media1 ? ohlc4tf4 : tf4media1
// tf4_close = ohlc4tf4 > tf4media1 ? tf4media1 : ohlc4tf4
// tf4_high = htf4
// tf4_low = ltf4

tf4o= tf4media2
tf4c= tf4media1
tf4h= tf4media3
tf4l= tf4media4

tf4haclose = (tf4o+tf4h+tf4l+tf4c)/4
tf4haopen = 0.0
tf4haopen := na(tf4haopen[1]) ? (tf4o + tf4c)/2 : (tf4haopen[1] + tf4haclose[1]) / 2
tf4hahigh = math.max (tf4h, math.max(tf4haopen,tf4haclose))
tf4halow = math.min (tf4l, math.min(tf4haopen,tf4haclose))

tf4o2 = ta.wma(tf4haopen, 6)
tf4c2 = ta.wma(tf4haclose, 6)
tf4h2 = ta.wma(tf4hahigh, 6)
tf4ll2 = ta.wma(tf4halow, 6)

// ——————————————————————————————————————————————————————————————————————————————————————————————————————
// ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
// plot candle     "None"

tf4__open = tf4o2
tf4__high = tf4h2
tf4__low = tf4ll2
tf4__close = tf4c2

tf4_bodyColor = (tf4__close > tf4__open ? color.rgb(56,74,87, 40) : color.rgb(100, 27, 12, 0))// ohlc4 > media1 ? #00FFFF : #FFA500
tf4_wickcolor = shcw4?(tf4__close > tf4__open ? #00FFFF : #FFA500):color.new(color.black,100) // ohlc4 > Keltma ? #00FFFF : #FFA500

plotcandle(open=icc and hmtf4 and phmtf4?tf4__open:na, high=icc and hmtf4 and phmtf4?tf4__high:na, low=icc and hmtf4 and phmtf4?tf4__low:na, close=icc and hmtf4 and phmtf4?tf4__close:na, title="Candle", color=tf4_bodyColor, wickcolor=tf4_wickcolor)
getCurrentLabel(icc and hmtf4 and phmtf4?tf4__close:na,tf4__close,"HC TF4(" + hmtf3res + ")",false, tf4_bodyColor, false)     
//}

//}

//Baseline PLOT
//{
tl = MMDon.ma(tltype, tlsrc, malen, high, low, ohlc4, jurik_power, kidiv)
plot(icc and show_ma?tl:na, color=tl>tl[1]?color.rgb(56,74,87, 20):color.rgb(100, 27, 12, 20), linewidth=Thicknes, transp=Transparency )//green red
//}

//SESSION IN BOXES DISPLAY SECTION (START) -----------------------------------------------------------------------------------------------------------
//{
nyColour  = color.red
blColour  = color.blue
lonColour = color.green
tokColour = color.orange
sydColour = #3CB371
int sess1 = time(timeframe.period, i_sess1,tz)
int sess2 = time(timeframe.period, i_sess2,tz)
int sess3 = time(timeframe.period, i_sess3,tz)
int sess4 = time(timeframe.period, i_sess4,tz)
int sess5 = time(timeframe.period, i_sess5,tz)

[sess1T, sess1B] = SessInBoxes.get_positions_func(sess1, LOOKBACKMINS)
[sess2T, sess2B] = SessInBoxes.get_positions_func(sess2, LOOKBACKMINS)
[sess3T, sess3B] = SessInBoxes.get_positions_func(sess3, LOOKBACKMINS)
[sess4T, sess4B] = SessInBoxes.get_positions_func(sess4, LOOKBACKMINS)
[sess5T, sess5B] = SessInBoxes.get_positions_func(sess5, LOOKBACKMINS)

[lon_co_s, lon_cu_s] = SessInBoxes.get_op_stricts(sess1, SessInBoxes.is_start(sess1), sess1T, sess1B,i_o_minutes)
[ny_co_s, ny_cu_s] = SessInBoxes.get_op_stricts(sess2, SessInBoxes.is_start(sess2), sess2T, sess2B,i_o_minutes)
[tok_co_s, tok_cu_s] = SessInBoxes.get_op_stricts(sess3, SessInBoxes.is_start(sess3), sess3T, sess3B,i_o_minutes)
[bl_co_s, bl_cu_s] = SessInBoxes.get_op_stricts(sess4, SessInBoxes.is_start(sess4), sess4T, sess4B,i_o_minutes)
[syd_co_s, syd_cu_s] = SessInBoxes.get_op_stricts(sess5, SessInBoxes.is_start(sess5), sess5T, sess5B,i_o_minutes)

lon_s = icc?SessInBoxes.draw(i_show_sess1, sess1, lonColour, "London", i_sess_extend, i_sess_fib, i_sess_op,i_label_chg,i_label_size,i_label_position,i_o_minutes,i_o_opacity,RECT_LINESTYLE,i_sess_border_width,i_sess_bgopacity,i_show_history,i_show_closed,i_label_show,i_f_linewidth,FIB_LINESTYLE, sess1T, sess1B):false
ny_s = icc?SessInBoxes.draw(i_show_sess2, sess2, nyColour, "New York", i_sess_extend, i_sess_fib, i_sess_op,i_label_chg,i_label_size,i_label_position,i_o_minutes,i_o_opacity,RECT_LINESTYLE,i_sess_border_width,i_sess_bgopacity,i_show_history,i_show_closed,i_label_show,i_f_linewidth,FIB_LINESTYLE, sess2T, sess2B):false
tok_s = icc?SessInBoxes.draw(i_show_sess3, sess3, tokColour, "Tokyo", i_sess_extend, i_sess_fib,  i_sess_op,i_label_chg,i_label_size,i_label_position,i_o_minutes,i_o_opacity,RECT_LINESTYLE,i_sess_border_width,i_sess_bgopacity,i_show_history,i_show_closed,i_label_show,i_f_linewidth,FIB_LINESTYLE, sess3T, sess3B):false
bl_s = icc?SessInBoxes.draw(i_show_sess4, sess4, blColour, "Berlin", i_sess_extend, i_sess_fib,   i_sess_op,i_label_chg,i_label_size,i_label_position,i_o_minutes,i_o_opacity,RECT_LINESTYLE,i_sess_border_width,i_sess_bgopacity,i_show_history,i_show_closed,i_label_show,i_f_linewidth,FIB_LINESTYLE, sess4T, sess4B):false
syd_s = icc?SessInBoxes.draw(i_show_sess5, sess5, sydColour, "Sydney", i_sess_extend, i_sess_fib, i_sess_op,i_label_chg,i_label_size,i_label_position,i_o_minutes,i_o_opacity,RECT_LINESTYLE,i_sess_border_width,i_sess_bgopacity,i_show_history,i_show_closed,i_label_show,i_f_linewidth,FIB_LINESTYLE, sess5T, sess5B):false


//}

//ATR STOP MASTER
//{
src = ohlc4    

bar = -1
bar := nz(bar[1]) + 1

var renkoBlock = math.abs(open - close)
renkoBlock := bar > 1 ? math.abs(open - close) == renkoBlock[1] and (close == high or close == low) ? renkoBlock[1] : -1 : math.abs(open - close) > 0 and (close == high or close == low) ? math.abs(open - close) : -1
isRenko = renkoBlock >= 0

var tk = syminfo.mintick
var blockMult = tk < 0.1 and tk != 0.025 and (tk != 0.01 or syminfo.pointvalue < 10 or syminfo.pointvalue * tk <= 1) and (tk != 0.001 or syminfo.pointvalue <= 1) and tk != 0.005 and tk != 0.0001 and tk != 0.0005 and tk != 0.03125 and tk != 0.015625 ? tk == 0.00005 or tk * 100 == 0.00005 ? 2 : 10 : 1
var block = blockMult * tk
    
getSessionVars() =>
    start = request.security(syminfo.tickerid, dintval, time, lookahead = barmerge.lookahead_on)
    newSession = ta.change(start)? 1: 0

    var sinceNew = 0
    sinceNew := newSession ? 0 : nz(sinceNew[1]) + 1
    
    isChartIntval = isRenko or (sinceNew == 0 and sinceNew[1] == 0 and sinceNew[2] == 0) 
    
    var newSessionCount = 0
    newSessionCount := newSession ? nz(newSessionCount[1]) + 1 : nz(newSessionCount[1])

    oldSinceNew1 = 0
    oldSinceNew1 := newSession ? sinceNew[1] : nz(oldSinceNew1[1])
    
    oldSinceNew2 = 0
    oldSinceNew2 := newSession ? oldSinceNew1[1] : nz(oldSinceNew2[1])
    
    lastSessionTime1 = time
    lastSessionTime1 := newSession ? time / 1000 : nz(lastSessionTime1[1])
    
    lastSessionTime2 = time
    lastSessionTime2 := newSession ? lastSessionTime1[1] : nz(lastSessionTime2[1])
    
    isIntraday = lastSessionTime1 - lastSessionTime2 < 86400
    
    var barsInInt = 0
    
    var gaps = array.new_int(0)
    var known = array.new_int(0)
    var found = array.new_int(0)
    var newSessions = array.new_int(0)
    
    var gapCount = 1
    var sessionEnd = -1
    
    // store known end points to session ends
    
    var seconds = 0
    seconds := hour(time) * 3600 + minute(time) * 60 + second(time)
    
    if newSession
        array.unshift(found, seconds[1])
        
        if array.size(found) > 1
            if array.get(found, 0) != array.get(found, 1)
                array.clear(found)
                gapCount
            else if array.size(found) > (gapCount + 1)
                array.clear(found)
                sessionEnd := seconds[1]
                gapCount
    
    if barstate.isnew and not array.includes(known, seconds[1]) and isIntraday and sessionEnd < 0
        if not isRenko and bar_index > 300
            if newSession
                if (sinceNew[1] + 1) < 0.9 * (barsInInt[1] + 1)
                    if (array.lastindexof(gaps, seconds[1]) - array.indexof(gaps, seconds[1])) <= gapCount
                        array.push(gaps, seconds[1])
                        array.sort(gaps, order.ascending)
            
            if array.includes(gaps, seconds[1]) and ((time - time[1]) == (time[1] - time[2]) or not newSession)
                if (time - time[1]) == (time[1] - time[2])
                    array.push(known, seconds[1])
                    
                array.clear(array.slice(gaps, array.indexof(gaps, seconds[1]), array.lastindexof(gaps, seconds[1]) + 1))
            
    isGap = not newSession and not array.includes(known, seconds) and (array.lastindexof(gaps, seconds) - array.indexof(gaps, seconds)) > gapCount
    
    // find the most frequence bar count in a new session
    
    var newCount = -1
    
    if newSession and not isChartIntval and sinceNew[1] > 0
        if newSessionCount > 5
            array.push(newSessions, sinceNew[1])
            array.sort(newSessions, order.ascending)
            
            if array.size(newSessions) > 1
                j = 0
                newCount1 = -1
                selected = sinceNew[1]
                
                for i = 0 to array.size(newSessions) - 1
                    e = array.get(newSessions, j)
                    
                    li = array.lastindexof(newSessions, e)
                    c = li - array.indexof(newSessions, e)
                    
                    if e > 0 and (c > newCount1 or (c == newCount1 and e > selected))
                        newCount1 := c
                        selected := e
                        
                    j := li + 1
                    
                    if j >= array.size(newSessions)
                        break
                        
                barsInInt := selected
                newCount := newCount1
                
        else
            barsInInt := sinceNew[1]
        
    //barsInInt := round(__barsInInt)
    
    eTF = isChartIntval or barsInInt == sinceNew or isGap or seconds == sessionEnd
    
    [newSession, sinceNew, barsInInt, isChartIntval, eTF, gaps, newSessionCount, newCount]
    
[newSession, sinceNew, barsInInt, isChartIntval, eTF, gaps, newSessionCount, newCount] = getSessionVars()

atrCalc() =>    
    // DI-Pos, DI-Neg, ADX
    
    hR = ta.change(high)
    lR = -ta.change(low)
    
    dmPos = hR > lR ? math.max(hR, 0) : 0
    dmNeg = lR > hR ? math.max(lR, 0) : 0
    
    sTR = ta.tr
    sTR := nz(sTR[1]) - nz(sTR[1]) / adxLen + ta.tr
    sDMPos = ta.tr
    sDMPos := nz(sDMPos[1]) - nz(sDMPos[1]) / adxLen + dmPos
    sDMNeg = ta.tr
    sDMNeg := nz(sDMNeg[1]) - nz(sDMNeg[1]) / adxLen + dmNeg
    
    DIP = sDMPos / sTR * 100
    DIN = sDMNeg / sTR * 100
    DX = math.abs(DIP - DIN) / (DIP + DIN) * 100
    adx = ta.sma(DX, adxLen)
    
    // Heikin-Ashi
    
    xClose = ohlc4
    xOpen = open
    xOpen := (nz(xOpen[1]) + nz(xClose[1])) / 2
    xHigh = math.max(high, math.max(xOpen, xClose))
    xLow = math.min(low, math.min(xOpen, xClose))
    
    // Trailing ATR
    
    v1 = math.abs(xHigh - xClose[1])
    v2 = math.abs(xLow - xClose[1])
    v3 = xHigh - xLow
    
    trueRange = math.max(v1, math.max(v2, v3))
    atr = useHeikin ? ta.rma(trueRange, atrLen) : ta.atr(atrLen)
    
    m = m1
    m := ta.rising(adx, 1) and (adx < adxThresh or not aboveThresh) ? m1 : ta.falling(adx, 1) or (adx > adxThresh and aboveThresh) ? m2 : nz(m[1])
    mUp = DIP >= DIN ? m : m2
    mDn = DIN >= DIP ? m : m2
    
    src_ = useHeikin ? (xOpen + xHigh + xLow + xClose) / 4 : src
    c = useHeikin ? xClose : close
    t = useHeikin ? (xHigh + xLow) / 2 : hl2
    
    up = t - mUp * atr
    dn = t + mDn * atr
    
    TUp = close
    TUp := math.max(src_[1], math.max(c[1], close[1])) > TUp[1] ? math.max(up, TUp[1]) : up
    TDown = close
    TDown := math.min(src_[1], math.min(c[1], close[1])) < TDown[1] ? math.min(dn, TDown[1]) : dn
    
    trend = 1
    trend := math.min(src_, math.min(c, close)) > TDown[1] ? 1 : math.max(src_, math.max(c, close)) < TUp[1]? -1 : nz(trend[1], 1)
    
    // ceil positive trend to nearest pip/tick, floor negative trend to nearest pip/tick
    stop = trend > 0 ? math.ceil(TUp / block) * block : math.floor(TDown / block) * block
    trendChange = ta.change(trend)
    
    [adx, trend, stop, trendChange]

[adx, _trend, _stop, _trendChange] = atrCalc()

// Fixes intervals that are uneven, i.e. 120 on normal 6.5 hour NYSE day
// This will happen if a 2H interval closes at 4:00 EST but opened at 3:30
// EST. This is a new session candle. The 9:30 open the next day will also
// be a new session candle, which shouldn't happen. There should never be
// 2 consecutive candles that are new session candles, unless the indicator
// interval is less than or equal to the chart interval. If there are 3
// consecutive candles where each candle is a new session, then the chart
// interval is <= the declared indicator interval.

trend = useIntval or isChartIntval ? _trend : request.security(syminfo.tickerid, dintval, _trend[1], lookahead = barmerge.lookahead_on)
stop = useIntval or isChartIntval ? _stop : request.security(syminfo.tickerid, dintval, _stop[1], lookahead = barmerge.lookahead_on)
trendChange = useIntval or isChartIntval ? _trendChange : request.security(syminfo.tickerid, dintval, _trendChange[1], lookahead = barmerge.lookahead_on)

// Plot
//color.rgb(56,74,87, 20):color.rgb(100, 27, 12, 20)
upC = color.aqua
dnC = color.red
upC2 = color.aqua
dnC2 = color.red
trans = #00000000

lineColor = not(trendChange) or trendChange[1] ? trend > 0 ? upC : dnC : trans
fillColor = not(trendChange) or trendChange[1] ? trend > 0 ? upC2 : dnC2 : trans

// Can't figure out any other way to solve this issue for fixing a problem where
// the indicator interval is greater than the chart interval, and the indicator is
// not divisible by the chart interval without a remainder.
oddIntervalTest = (lineColor[1] == upC and lineColor[0] == dnC) or (lineColor[1] == dnC and lineColor[0] == upC)
stopColor = oddIntervalTest ? trans : lineColor
trendChangeReal = stopColor == trans
shapeColor = trendChangeReal ? trend > 0 ? color.aqua : color.red : trans

upperBand = stop + bandHalfWidth * block
lowerBand = stop - bandHalfWidth * block

stopPlot = plot(icc and not showLast ? stop : na, color = stopColor, title = "ATR Trend")
upper = plot(icc and not showLast and bandHalfWidth > 0 ? upperBand : na, color = oddIntervalTest ? trans : trend > 0 ? bandColorPos : bandColorNeg, style = plot.style_circles, editable = false)
lower = plot(icc and not showLast and bandHalfWidth > 0 ? lowerBand : na, color = oddIntervalTest ? trans : trend > 0 ? bandColorPos : bandColorNeg, style = plot.style_circles, editable = false)

plotshape(icc and not showLast and trendChangeReal ? stop : na, style = shape.circle, size = size.tiny, location = location.absolute, color = shapeColor, title = "Change")

rez1 = useIntval ? timeframe.period : dintval
rez2 = rez1 == "1"? "M1": rez1 == "2"? "M2": rez1 == "3"? "M3": rez1 == "5"? "M5": rez1 == "15"? "M15": rez1 == "30"? "M30": rez1 == "45"? "M45": rez1 == "60"? "H1": rez1 == "120"? "H2": rez1 == "180"? "H3": rez1 == "240"? "H4": rez1 == "480"? "H8": rez1 == "720"? "H12": rez1 == "D"? "Day": rez1 == "M"? "Month": rez1 == "3M"? "Quarter": rez1 == "12M"? "Year": dintval  
timeSuffix = showSessType ? " (" + rez2 + ")" : ""

labelSize = size == 0 ? size.auto : size == 1 ? size.tiny : size == 2 ? size.small : size == 3 ? size.normal : size == 4 ? size.large : size.huge

getPivot(price, col, width, lineStyle) => 
    var line l = na
    
    if not na(price)
        l := icc?line.new(bar_index, price, bar_index, price, color = col, style = lineStyle, width = width):na
        
        change = ta.change(price) != 0
        
        pLine = l
        pLine := change ? l : pLine[1]
        
        pBar = bar_index
        pBar := change ? bar_index : nz(pBar[1])
        
        if change
            x1 = ta.valuewhen(change, pBar[1], 1)
            line.set_x1(l, x1)
        
            line.delete(l[1])
            line.delete(pLine[1])
        else
            line.set_x2(pLine, bar_index)
            line.delete(l)
                
        if not change[1]
            line.delete(l[1])
            
getLabel(x, price, prefix, col, textCol, isUp) =>
    var label l = na
    
    if not na(price)
        p = math.round(price / syminfo.mintick) * syminfo.mintick
        
        l := icc ?label.new(x, price, text = prefix + "\n" + str.tostring(p), color = col, textcolor = textCol, size = labelSize):na
        
        label.set_style(l, isUp ? label.style_label_down : label.style_label_up)
         
        pLabel = l
        pLabel := newSession ? l : pLabel[1]
        
        len = 0.0
        len := newSession ? barsInInt[1] + 1 : nz(len[1])
        
        if newSession
            if len > 0
                label.delete(l[1])
                
            label.delete(pLabel[1])
        else
            label.delete(l)
            
        if not newSession[1] and len > 0
            label.delete(l[1])
        
getLabel(ta.change(stop) ? bar_index : math.max(0, bar_index - offset), showPrice ? stop : na, "ATR" + timeSuffix, trend > 0 ? labelColorPos : labelColorNeg, textColor, trend < 0)
getPivot(showLast ? stop : na, trend > 0 ? bandColorPos : bandColorNeg, 1, line.style_solid)
getPivot(showLast and bandHalfWidth > 0 ? stop + bandHalfWidth * block : na, trend > 0 ? bandColorPos : bandColorNeg, 2, line.style_dotted)
getPivot(showLast and bandHalfWidth > 0 ? stop - bandHalfWidth * block : na, trend > 0 ? bandColorPos : bandColorNeg, 2, line.style_dotted)

//}

//SIGNAL VALIDATION AND PLOTS 
//{

strictTimeframe = strictTok or strictbl or strictLon or strictSyd or strictNy ? ((strictTok and tok_s) or (strictbl and bl_s) or (strictLon and lon_s) or (strictSyd and syd_s) or (strictNy and ny_s)) : true
strictTimeframeORb = strictTokOR or strictblOR or strictLonOR or strictSydOR or strictNyOR ? ((strictTokOR and tok_co_s) or (strictblOR and bl_co_s) or (strictLonOR and lon_co_s) or (strictSydOR and syd_co_s) or (strictNyOR and ny_co_s)) : true 
strictTimeframeORs = strictTokOR or strictblOR or strictLonOR or strictSydOR or strictNyOR ? ((strictTokOR and tok_cu_s) or (strictblOR and bl_cu_s) or (strictLonOR and lon_cu_s) or (strictSydOR and syd_cu_s) or (strictNyOR and ny_cu_s)) : true

var long=false
var short=false
long:=false
short:=false

long:=(tl_strict? close>tl :true) and (hc_strict? (hc_strict_t=="Close"?close>__close:close>__high) :true) and (hc_strict2? (hc_strict_t2=="Close"?close>___close:close>___high) :true) and  (atrs_strict?close>stop:true)
short:=(tl_strict? close<tl :true) and (hc_strict? (hc_strict_t=="Close"?close<__close:close<__low) :true) and (hc_strict2? (hc_strict_t2=="Close"?close<___close:close<___low) :true) and (atrs_strict?close<stop:true)

long:= long and (hmtf2 or hmtf4 or hmtf4? (hmtf2?(hmtf_strict_t=="Close"?close>tf2__close:close>tf2__high):true) and (hmtf3?(hmtf_strict_t=="Close"?close>tf3__close:close>tf3__high):true) and (hmtf4?(hmtf_strict_t=="Close"?close>tf4__close:close>tf4__high):true) :long)
short:= short and (hmtf2 or hmtf4 or hmtf4? (hmtf2?(hmtf_strict_t=="Close"?close<tf2__close:close<tf2__low):true) and (hmtf3?(hmtf_strict_t=="Close"?close<tf3__close:close<tf3__low):true) and (hmtf4?(hmtf_strict_t=="Close"?close<tf4__close:close<tf4__low):true) :short)

long:=conf_c?long and close>open:long
short:=conf_c?short and close<open:short

long:=strictTimeframe and long
short:=strictTimeframe and short
long:=strictTimeframeORb and long
short:=strictTimeframeORs and short

long:= (not(tl_strict) and not(hc_strict) and not(hc_strict2) and not(hmtf2 or hmtf4 or hmtf4) and not(atrs_strict))?false:long
short:= (not(tl_strict) and not(hc_strict) and not(hmtf2 or hmtf4 or hmtf4) and not(atrs_strict))?false:short

//}



//MM LOGIC 
//{
var int pos = 0
pos:= long? 1 : short? -1 : pos[1]

longCond = long and pos[1]!= 1
shortCond = short and pos[1]!=-1
exit_longCond = long and pos[1]!= 1
exit_shortCond = short and pos[1]!=-1

buySignal = longCond
sellSignal = shortCond

//MM Vars
//{
var firsttrade = 0
var totalbuy = 0
var totalsell = 0
var winbuytp1 = 0
var winselltp1 = 0
var lastrst         = 0
var active_trades = 0
var conswin         = 0
var consloss        = 0
var long_pos        = 0
var short_pos       = 0
var conswinlist     = array.new_int(0,0)
var conslosslist    = array.new_int(0,0)
var grossprofit     = array.new_float(0,0.0)
var grossloss       = array.new_float(0,0.0)
var array_runner_id = array.new_int()
var array_runner_sl = array.new_float()
var array_runner_dir = array.new_string()

var lossbuy = 0
var losssell = 0

var pos_c = 0
var int trade_state = 0
var float tp1 = na
var float tp2 = na
var float tp3 = na
var float sl = na
var float entry = na
var int et = 0

line entryLine = na
line stopLine = na
line tp1Line = na
line tp2Line = na
line tp3Line = na

label entryLabel = na
label stopLabel = na
label tp1Label = na
label tp2Label = na
label tp3Label = na

dt = time - time[1]

var bool tp1_hit = false
var bool tp1_hit_persist = false

var bool tp2_hit = false
var bool tp2_hit_persist = false

var bool tp3_hit = false
var bool tp3_hit_persist = false

var bool sl_hit = false

tp1_hit_persist := false
tp2_hit_persist := false
tp3_hit_persist := false
sl_hit := false

var id_s_tp1 = ""
var id_s_tp2 = ""
var id_s_tp3 = ""
var id_s_r = ""
var id_l_tp1 = ""
var id_l_tp2 = ""
var id_l_tp3 = ""
var id_l_r = ""
//}

//Exit Signal Finder: If an Exit signal is present, close the trade
//{
var is_exit_t = false
is_exit_t := false
if exit_cond != "NO EXIT COND." and not is_exit_t and trade_state != 0
    if exit_cond == "HEIKIN ASHI OPPOSITE CANDLE"
        if trade_state > 0 
            is_exit_t := __open>__close
        else if trade_state < 0
            is_exit_t := __open<__close
    else if exit_cond == "TRADITIONAL BASELINE"
        if trade_state > 0 
            is_exit_t := close<tl
        else if trade_state < 0
            is_exit_t := close>tl
    else if exit_cond == "ATR BAND STOP"
        if trade_state > 0 
            is_exit_t := close<stop
        else if trade_state < 0
            is_exit_t := close>stop
    else if exit_cond == "HEIKIN ASHI BASELINE"
        if trade_state > 0
            if ___close > ___open
                is_exit_t := close<___open
            else
                is_exit_t := close<___close
        else if trade_state < 0
            if ___close > ___open
                is_exit_t := close>___close
            else
                is_exit_t := close>___open
    
// if(is_exit_tr and not is_exit_t and trade_state != 0)
//     if exit_tr == "BB Squeeze" 
//         if trade_state > 0  
//             is_exit_t:=exit_src=="Close"?(close<=bbsqup or close<=bbsqlow):(low<=bbsqup or low<=bbsqlow)
//         else if trade_state < 0
//             is_exit_t:=exit_src=="Close"?(close>=bbsqup or close>=bbsqlow):(high>=bbsqup or high>=bbsqlow)
// if(is_exit_t and trade_state > 0) and estrat
//     strategy.close_all(comment="L_Ex.(pos_n = " + str.tostring(pos_c) + ")", alert_message="L_Ex.(pos_n = " + str.tostring(pos_c) + ")")
//     sl_hit := true
//     trade_state := 0
//     pos := 0
//     code = str.format("{0},closelong,{1}", pineconnid, getTickerID(syminfo.ticker))
//     alert(code,alert.freq_once_per_bar_close)
// else if (is_exit_t and trade_state < 0) and estrat
//     strategy.close_all(comment="S_Ex.(pos_n = " + str.tostring(pos_c) + ")", alert_message="S_Ex.(pos_n = " + str.tostring(pos_c) + ")")
//     sl_hit := true
//     trade_state := 0
//     pos := 0
//     code = str.format("{0},closeshort,{1}", pineconnid, getTickerID(syminfo.ticker))
//     alert(code,alert.freq_once_per_bar_close)
//}

//If trade exists, check advancements
//{
if trade_state > 0

    if sellSignal
        if (low <= sl) 
            sl_hit := true
        //     if estrat
        //         strategy.close_all(comment="L_SL HIT (pos_n = " + str.tostring(pos_c) + ")", alert_message="LONG SL HIT (pos_n = " + str.tostring(pos_c) + ")")
        // else
        //     if estrat
        //         strategy.close_all(comment="Exit Long For Short", alert_message="Exit Long For Short")
        //         code = str.format("{0},closelong,{1}", pineconnid, getTickerID(syminfo.ticker))
        //         alert(code,alert.freq_once_per_bar_close)
            // if sendDiscordChatMessage 
            //     alert(exitL_signal_change_msg,alert.freq_once_per_bar_close)
        trade_state := 0
        pos := 0
        // if runn_check
        //     array.remove(array_runner_dir, 0)
        //     array.remove(array_runner_sl, 0)
        //     array.remove(array_runner_id, 0)
    else if low <= sl 
        // if estrat and trade_state != 1
        //     strategy.close_all(comment="L_SL HIT (pos_n = " + str.tostring(pos_c) + ")", alert_message="LONG SL HIT (pos_n = " + str.tostring(pos_c) + ")")
        sl_hit := true
        trade_state := 0
        pos := 0
    // else if(is_exit_tr and (not is_exit_t) and (not sl_hit))
    //     if exit_tr == "BB Squeeze"
    //         is_exit_t:=exit_src=="Close"?(close<=bbsqup or close<=bbsqlow):(low<=bbsqup or low<=bbsqlow)
        
    
    if(is_exit_t)
        //strategy.close_all(comment="L_Ex.(pos_n = " + str.tostring(pos_c) + ")", alert_message="L_Ex.(pos_n = " + str.tostring(pos_c) + ")")
        sl_hit := true
        trade_state := 0
        pos := 0
        //code = str.format("{0},closelong,{1}", pineconnid, getTickerID(syminfo.ticker))
        //alert(code,alert.freq_once_per_bar_close)
        
    if trade_state == 1 and high >= tp1
        //Sell this position - check if we have TP2
        tp1_hit := true
        tp1_hit_persist := true
        if enableTP2
            trade_state := 2
            if trade_state == 2 and high >= tp2
                //Sell this position - check if we have TP3
                tp2_hit := true
                tp2_hit_persist := true
                if enableTP3
                    trade_state := 3
                    if trade_state == 3 and high >= tp3
                        tp3_hit := true
                        tp3_hit_persist := true
                        trade_state := 0
                        pos := 0
                else
                    trade_state := 0
                    pos := 0
        else
            trade_state := 0
            pos := 0
    
    else if trade_state == 2 and high >= tp2
        //Sell this position - check if we have TP3
        tp2_hit := true
        tp2_hit_persist := true
        if enableTP3
            trade_state := 3
            if trade_state == 3 and high >= tp3
                tp3_hit := true
                tp3_hit_persist := true
                trade_state := 0
                pos := 0
        else
            trade_state := 0
            pos := 0
    
    else if trade_state == 3 and high >= tp3
        tp3_hit := true
        tp3_hit_persist := true
        trade_state := 0
        pos := 0
    

if trade_state < 0
    if buySignal
        if (high >= sl)
            sl_hit := true
        //     if estrat
        //         strategy.close_all(comment="S_SL HIT (pos_n = " + str.tostring(pos_c) + ")", alert_message="SHORT SL HIT (pos_n = " + str.tostring(pos_c) + ")")
        // else
        //     if estrat
        //         strategy.close_all(comment="Exit Short For Long", alert_message="Exit Short For Long")
        //         code = str.format("{0},closeshort,{1}", pineconnid, getTickerID(syminfo.ticker))
        //         alert(code,alert.freq_once_per_bar_close)
            // if sendDiscordChatMessage 
            //     alert(exitS_signal_change_msg,alert.freq_once_per_bar_close)
        trade_state := 0
        pos := 0
        // if runn_check
        //     array.remove(array_runner_dir, 0)
        //     array.remove(array_runner_sl, 0)
        //     array.remove(array_runner_id, 0)

    else if high >= sl
        // if estrat and trade_state != -1
        //     strategy.close_all(comment="S_SL HIT (pos_n = " + str.tostring(pos_c) + ")", alert_message="SHORT SL HIT (pos_n = " + str.tostring(pos_c) + ")")
        sl_hit := true
        trade_state := 0
        pos := 0
    
    // else if(is_exit_tr and (not is_exit_t) and (not sl_hit))
    //     if exit_tr == "BB Squeeze" 
    //         is_exit_t:=exit_src=="Close"?(close>=bbsqup or close>=bbsqlow):(high>=bbsqup or high>=bbsqlow)
        
    if (is_exit_t)
        //strategy.close_all(comment="S_Ex.(pos_n = " + str.tostring(pos_c) + ")", alert_message="S_Ex.(pos_n = " + str.tostring(pos_c) + ")")
        sl_hit := true
        trade_state := 0
        pos := 0
        //code = str.format("{0},closeshort,{1}", pineconnid, getTickerID(syminfo.ticker))
        //alert(code,alert.freq_once_per_bar_close)
    
    if trade_state == -1 and low <= tp1
        //Sell this position - check if we have TP2
        tp1_hit := true
        tp1_hit_persist := true
        if enableTP2
            trade_state := -2
            if trade_state == -2 and low <= tp2
                //Sell this position - check if we have TP3
                tp2_hit := true
                tp2_hit_persist := true
                if enableTP3
                    trade_state := -3
                    if trade_state == -3 and low <= tp3
                        //Sell this position
                        tp3_hit := true
                        tp3_hit_persist := true
                        trade_state := 0
                        pos := 0
                else
                    trade_state := 0
                    pos := 0
        else
            trade_state := 0
            pos := 0
    
    else if trade_state == -2 and low <= tp2
        //Sell this position - check if we have TP3
        tp2_hit := true
        tp2_hit_persist := true
        if enableTP3
            trade_state := -3
            if trade_state == -3 and low <= tp3
                //Sell this position
                tp3_hit := true
                tp3_hit_persist := true
                trade_state := 0
                pos := 0
        else
            trade_state := 0
            pos := 0
    
    else if trade_state == -3 and low <= tp3
        //Sell this position
        tp3_hit := true
        tp3_hit_persist := true
        trade_state := 0
        pos := 0    
//}

//If trade does not exist, check if a new opportunity is present
//{
if trade_state == 0
    tp1_hit := false
    tp2_hit := false
    tp3_hit := false

    if buySignal
        pos_c := pos_c + 1
        trade_state := 1
        
        stop_mnt = ta.atr(Atrlen) * Atrmul 
        entry := round_price(close)
        et := time
        sl := round_price(close - stop_mnt)
        tp1 := round_price(close + stop_mnt*tp1x)
        if enableTP2
            tp2 := round_price(close + stop_mnt*tp2x)
        if enableTP3
            tp3 := round_price(close + stop_mnt*tp3x)
        // if enableRunner
        //     array.push(array_runner_id, pos_c)
        //     array.push(array_runner_sl, sl)
        //     array.push(array_runner_dir, "L")

    if sellSignal
        pos_c := pos_c + 1
        trade_state := -1
        
        stop_mnt = ta.atr(Atrlen) * Atrmul
        entry := round_price(close)
        et := time
        sl := round_price(close + stop_mnt)
        tp1 := round_price(close - stop_mnt*tp1x)
        if enableTP2
            tp2 := round_price(close - stop_mnt*tp2x)
        if enableTP3
            tp3 := round_price(close - stop_mnt*tp3x)
        // if enableRunner
        //     array.push(array_runner_id, pos_c)
        //     array.push(array_runner_sl, sl)
        //     array.push(array_runner_dir, "S")
//}

//Manage trade management lines (EP, SL, TP)
//{

if trade_state[1] > 0
    if barstate.islast
        stoplossInPips = round_pips(ta.atr(Atrlen)) * Atrmul
        stoplossInPips := round_pips(entry - sl)
        
        
        entryLine := line.new(et, entry,time + dt * 2,entry,color=color.gray,style=line.style_solid,xloc = xloc.bar_time)
        entryLabel := label.new(time + dt * 4, entry,text="Entry:" + str.tostring(entry, "#.0000"),color=#000000,textcolor=color.white,style=label.style_label_left,xloc = xloc.bar_time,textalign=text.align_left,size=size.normal)
        
        stopLine := line.new(et, sl,time + dt * 2,sl,color=#FF4500,style=line.style_solid,xloc = xloc.bar_time)
        stopLabel := label.new(time + dt * 4, sl,text="Stop:" + str.tostring(sl) + " /pips " + str.tostring(round_pips(entry - sl), "#.0"),color=#000000,textcolor=#e0043b,style=label.style_label_left,xloc = xloc.bar_time,textalign=text.align_left,size=size.normal)
        
        if tp1_hit == false
            tp1Line := line.new(et, tp1,time + dt * 2,tp1,color=#4169E1,style=line.style_solid,xloc = xloc.bar_time)
            tp1Label := label.new(time + dt * 4, tp1,text="TP1:" + str.tostring(tp1) + " /pips " + str.tostring(round_pips(tp1 - entry), "#.0"),color=#000000,textcolor=#607794,style=label.style_label_left,xloc = xloc.bar_time,textalign=text.align_left,size=size.normal)
        
        if enableTP2 and not tp2_hit
            tp2Line := line.new(et, tp2,time + dt * 2,tp2,color=#4169E1,style=line.style_solid,xloc = xloc.bar_time)
            tp2Label := label.new(time + dt * 4, tp2,text="TP2:" + str.tostring(tp2)+ " /pips " + str.tostring(round_pips(entry - tp2), "#.0"),color=#000000,textcolor=#607794,style=label.style_label_left,xloc = xloc.bar_time,textalign=text.align_left,size=size.normal)
        
        if enableTP3 and enableTP2 and not tp3_hit
            tp3Line := line.new(et, tp3,time + dt * 2,tp3,color=#4169E1,style=line.style_solid,xloc = xloc.bar_time)
            tp3Label := label.new(time + dt * 4, tp3,text="TP3:" + str.tostring(tp3)+ " /pips " + str.tostring(round_pips(entry - tp3), "#.0"),color=#000000,textcolor=#607794,style=label.style_label_left,xloc = xloc.bar_time,textalign=text.align_left,size=size.normal)
        
        
        
if trade_state[1] < 0
    if barstate.islast
        stoplossInPips = round_pips(ta.atr(Atrlen)) * Atrmul
        stoplossInPips := round_pips(sl - entry)//%100
        
        entryLine := icc?line.new(et, entry,time + dt * 2,entry,color=color.gray,style=line.style_solid,xloc = xloc.bar_time):na
        entryLabel := icc?label.new(time + dt * 4, entry,text="Entry:" + str.tostring(entry, "#.0000"),color=#000000,textcolor=color.white,style=label.style_label_left,xloc = xloc.bar_time,textalign=text.align_left,size=size.normal):na
        
        stopLine := icc?line.new(et, sl,time + dt * 2,sl,color=#FF4500,style=line.style_solid,xloc = xloc.bar_time):na
        stopLabel := icc?label.new(time + dt * 4, sl,text="Stop:" + str.tostring(sl)+ " /pips " + str.tostring(round_pips(sl - entry), "#.0"),color=#000000,textcolor=#e0043b,style=label.style_label_left,xloc = xloc.bar_time,textalign=text.align_left,size=size.normal):na
        
        if not tp1_hit
            tp1Line := icc?line.new(et, tp1,time + dt * 2,tp1,color=#4169E1,style=line.style_solid,xloc = xloc.bar_time):na
            tp1Label := icc?label.new(time + dt * 4, tp1,text="TP1:" + str.tostring(tp1)+ " /pips " + str.tostring(round_pips(entry - tp1), "#.0"),color=#000000,textcolor=#607794,style=label.style_label_left,xloc = xloc.bar_time,textalign=text.align_left,size=size.normal):na
        
        if enableTP2 and not tp2_hit
            tp2Line := icc?line.new(et, tp2,time + dt * 2,tp2,color=#4169E1,style=line.style_solid,xloc = xloc.bar_time):na
            tp2Label := icc?label.new(time + dt * 4, tp2,text="TP2:" + str.tostring(tp2)+ " /pips " + str.tostring(round_pips(entry - tp2), "#.0"),color=#000000,textcolor=#607794,style=label.style_label_left,xloc = xloc.bar_time,textalign=text.align_left,size=size.normal):na
        
        if enableTP3 and not tp3_hit
            tp3Line := icc?line.new(et, tp3,time + dt * 2,tp3,color=#4169E1,style=line.style_solid,xloc = xloc.bar_time):na
            tp3Label := icc?label.new(time + dt * 4, tp3,text="TP3:" + str.tostring(tp3)+ " /pips " + str.tostring(round_pips(entry - tp3), "#.0"),color=#000000,textcolor=#607794,style=label.style_label_left,xloc = xloc.bar_time,textalign=text.align_left,size=size.normal):na

//Clear the old lines
line.delete(entryLine[1])
label.delete(entryLabel[1])

line.delete(stopLine[1])
label.delete(stopLabel[1])

line.delete(tp1Line[1])
label.delete(tp1Label[1])

if enableTP2
    line.delete(tp2Line[1])
    label.delete(tp2Label[1])
    
if enableTP3
    line.delete(tp3Line[1])
    label.delete(tp3Label[1])

//}

//MM PLOTS
//{
//Lables for signals
plotshape(showSignals and icc and trade_state == 1 and trade_state != trade_state[1],style=shape.arrowup,color=#4169E1,size=size.small,location = location.belowbar,text="BUY", textcolor=color.white,title="buy-arrow")
plotshape(showSignals and icc and trade_state == -1 and trade_state != trade_state[1],style=shape.arrowdown,color=#FF4500,size=size.small,location = location.abovebar,text="SELL", textcolor=color.white,title="sell-arrow")

// and (not tp1and2 and not tp1and3 and not alltps) 
// and (not tp1and2 and not tp2and3 and not alltps) 
// and (not tp2and3 and not tp1and3 and not alltps) 

tp1and2 = tp1_hit_persist and tp2_hit_persist
tp2and3 = tp2_hit_persist and tp3_hit_persist
tp1and3 = tp1_hit_persist and tp3_hit_persist
alltps = tp1_hit_persist and tp2_hit_persist and tp3_hit_persist
plotshape(showSignals and icc and trade_state[1] != trade_state and trade_state[1] > 0 and (tp1_hit_persist) and sl_hit == false, style=shape.xcross,color=#4169E1,location = location.abovebar,text="TP1",textcolor=color.white,title="tp1-long")
plotshape(showSignals and icc and trade_state[1] != trade_state and trade_state[1] > 0 and (tp2_hit_persist) and sl_hit == false, style=shape.xcross,color=#4169E1,location = location.abovebar,text="TP2",textcolor=color.white,title="tp2-long")
plotshape(showSignals and icc and trade_state[1] != trade_state and trade_state[1] > 0 and (tp3_hit_persist) and sl_hit == false, style=shape.xcross,color=#4169E1,location = location.abovebar,text="TP3",textcolor=color.white,title="tp3-long")

plotshape(showSignals and icc and trade_state[1] > 0 and trade_state == 0 and sl_hit and (not is_exit_t), style=shape.xcross,color=#FF4500,location = location.belowbar,text="SL",textcolor=color.white,title="sl-long")
plotshape(showSignals and icc and trade_state[1] > 0 and trade_state == 0 and is_exit_t and sl_hit,style=shape.xcross,color=#FF4500,location = location.belowbar,text="L_Exit",textcolor=color.white,title="sl-exlong")

plotshape(showSignals and icc and trade_state[1] != trade_state and trade_state[1] < 0 and (tp1_hit_persist) and sl_hit == false, style=shape.xcross,color=#4169E1,location = location.belowbar,text="TP1",textcolor=color.white,title="tp1-short")
plotshape(showSignals and icc and trade_state[1] != trade_state and trade_state[1] < 0 and (tp2_hit_persist) and sl_hit == false, style=shape.xcross,color=#4169E1,location = location.belowbar,text="TP2",textcolor=color.white,title="tp2-short")
plotshape(showSignals and icc and trade_state[1] != trade_state and trade_state[1] < 0 and (tp3_hit_persist) and sl_hit == false, style=shape.xcross,color=#4169E1,location = location.belowbar,text="TP3",textcolor=color.white,title="tp3-short")

plotshape(showSignals and icc and trade_state[1] < 0 and trade_state == 0 and sl_hit and (not is_exit_t), style=shape.xcross,color=#FF4500,location = location.abovebar,text="SL",textcolor=color.white,title="sl-short")
plotshape(showSignals and icc and trade_state[1] < 0 and trade_state == 0 and is_exit_t and sl_hit,style=shape.xcross,color=#FF4500,location = location.abovebar,text="S_Exit",textcolor=color.white,title="sl-exshort")

//}
// //-----------------------------------------------------------------------------------------------------------------------------------------------
// /// Pivots

// SHILO      = input.bool(false, title = "SHOW HIGH LOW PIVOT POINT" )
// leftbarsx  = input.int(title="HILO LeftBars", defval=10)
// rightbarsx = input.int(title="HILO Rightbars", defval=10)

// ph = ta.pivothigh(leftbarsx, rightbarsx)
// pl = ta.pivotlow(leftbarsx, rightbarsx)
// /// Higher Highs and Higher Lows
// hl = ta.valuewhen(ph, ph, 0) < ta.valuewhen(ph[1], ph[1], 0)
// hh = ta.valuewhen(ph, ph, 0) > ta.valuewhen(ph[1], ph[1], 0)
// plotshape( SHILO  and hh?hh:na, title="Higher High", style=shape.square, location=location.abovebar, color=color.green, transp=20, text="[HH]", offset=-rightbarsx, size=size.auto)
// plotshape( SHILO  and hl?hl:na, title="Higher Low", style=shape.square, location=location.abovebar, color=color.red, transp=20, text="[HL]", offset=-rightbarsx, size=size.auto)

// /// Lower Lows and Lower Highs
// ll = ta.valuewhen(pl[1], pl[1], 0) > ta.valuewhen(pl, pl, 0)
// lh = ta.valuewhen(pl[1], pl[1], 0) < ta.valuewhen(pl, pl, 0)
// plotshape(SHILO  and ll?ll:na, title="Lower Low", style=shape.square, location=location.belowbar, color=color.red, transp=20, text="[LL]", offset=-rightbarsx, size=size.auto)
// plotshape(SHILO  and lh?lh:na, title="Lower High", style=shape.square, location=location.belowbar, color=color.green, transp=20, text="[LH]", offset=-rightbarsx, size=size.auto)

get_alert(side) =>
    side + " " + syminfo.ticker + " q= 1%"

priceformat(x) =>
    str.tostring(math.abs(close - x)/syminfo.mintick, "#")

//LONG MESSAGES
default_long_alert_msg = str.format("buy {0} sl={1} tp1={2} tp2={3} tp3={4}", syminfo.tickerid, priceformat(sl), priceformat(tp1), priceformat(tp2), priceformat(tp3))


//SHORT MESSAGES
default_short_alert_msg = str.format("sell {0} sl={1} tp1={2} tp2={3} tp3={4}", syminfo.tickerid, priceformat(sl), priceformat(tp1), priceformat(tp2), priceformat(tp3))


//STOP MESSAGES
default_stop_alert_msg = str.format("{0} stop loss hit @ {1} -{2} pips", syminfo.tickerid, priceformat(sl), priceformat( math.abs(entry - sl) ))
default_bestop_alert_msg = str.format("{0} break even stop loss hit @ {1} -{2} pips", syminfo.tickerid, priceformat(sl), priceformat( math.abs(entry - sl) ))
default_tsstop_alert_msg = str.format("{0} trailing stop loss hit @ {1} -{2} pips", syminfo.tickerid, priceformat(sl), priceformat( math.abs(entry - sl) ))
//TP MESSAGES
default_tp1_alert_msg = str.format("{0} tp1 hit @ {1} +{2} pips", syminfo.tickerid, priceformat(tp1), priceformat(  math.abs(entry - tp1)  ))
default_tp2_alert_msg = str.format("{0} tp2 hit @ {1} +{2} pips", syminfo.tickerid, priceformat(tp2), priceformat(  math.abs(entry - tp2)  ))
default_tp3_alert_msg = str.format("{0} tp2 hit @ {1} +{2} pips", syminfo.tickerid, priceformat(tp3), priceformat(  math.abs(entry - tp3)  ))

//BE MESSAGES
default_breakeven_alert_msg = str.format("{0} tp hit sl moved to breakeven @ {1}", syminfo.tickerid, priceformat(entry), priceformat(  math.abs(entry - tp1)  ))
default_sltotp1_msg = str.format("{0} tp2 hit sl moved to tp1 @ {1}", syminfo.tickerid, priceformat(tp1), priceformat(  math.abs(entry - tp1)  ))


if trade_state == 1 and trade_state != trade_state[1] and long_alert
    alert(default_long_alert_msg,alert.freq_once_per_bar_close)

if trade_state == -1 and trade_state != trade_state[1] and short_alert
    alert(default_short_alert_msg,alert.freq_once_per_bar_close)

if trade_state[1] == 1 and (sl_hit) and tp3_hit==false and stop_alert
    alert(default_stop_alert_msg,alert.freq_once_per_bar_close)

if trade_state[1] == -1 and (sl_hit) and tp3_hit==false and stop_alert
    alert(default_stop_alert_msg,alert.freq_once_per_bar_close)

if trade_state[1] != 0 and (sl_hit) and tp1_hit and BE=="BE after TP1" and stop_alert
    alert(default_bestop_alert_msg,alert.freq_once_per_bar_close)

if trade_state[1] != 0 and (sl_hit) and tp2_hit and BE=="BE after TP2" and stop_alert
    alert(default_bestop_alert_msg,alert.freq_once_per_bar_close)

if trade_state[1] != 0 and not(sl_hit) and tp1_hit and BE=="BE after TP1" and breakeven_alert
    alert(default_breakeven_alert_msg,alert.freq_once_per_bar_close)

if trade_state[1] != 0 and (sl_hit) and tp2_hit and BE=="BE after TP2" and stop_alert
    alert(default_breakeven_alert_msg,alert.freq_once_per_bar_close)

if trade_state[1] != 0 and not (sl_hit) and tp2_hit and isTPscale and sltotp1_alert
    alert(default_sltotp1_msg,alert.freq_once_per_bar_close)

if trade_state[1] != 0 and (sl_hit) and tp2_hit and isTPscale and stop_alert
    alert(default_tsstop_alert_msg,alert.freq_once_per_bar_close)

if trade_state[1] == 1 and tp1_hit and tp1_hit[1]==false and tp1_alert
    alert(default_tp1_alert_msg,alert.freq_once_per_bar_close)

if trade_state[1] == -1 and tp1_hit and tp1_hit[1]==false and tp1_alert
    alert(default_tp1_alert_msg,alert.freq_once_per_bar_close)
    
if trade_state[1] == 1 and tp2_hit and tp2_hit[1]==false and tp2_alert
    alert(default_tp2_alert_msg,alert.freq_once_per_bar_close)

if trade_state[1] == -1 and tp2_hit and tp2_hit[1]==false and tp2_alert
    alert(default_tp2_alert_msg,alert.freq_once_per_bar_close)
    
if trade_state[1] == 1 and tp3_hit and tp3_alert
    alert(default_tp3_alert_msg,alert.freq_once_per_bar_close)

if trade_state[1] == -1 and tp3_hit and tp3_alert
    alert(default_tp3_alert_msg,alert.freq_once_per_bar_close)
    
// ——————————————————————————————————————————————————————————————————————————————————————————————————————
// ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
// Calculator panel
// ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
// ——————————————————————————————————————————————————————————————————————————————————————————————————————
if mobileDevice == "Mobile"
    var riskCalculatorTable = table.new(position = position.bottom_left, columns = 2, rows= 8, frame_color = color.black, frame_width = 4, border_width = 1, border_color = color.rgb(255, 0, 0, 100))
    if barstate.islast and showCalculator
        table.cell(table_id = riskCalculatorTable, column = 0, row = 0, text = "🦁MM RISK🦁", bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white, text_halign=text.align_center, text_size= size.tiny)
        
        table.cell(table_id = riskCalculatorTable, column = 0, row = 2, text = "💰 Account Size:", text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white, text_size= size.tiny)
        table.cell(table_id = riskCalculatorTable, column = 1, row = 2, text = "💰$" + str.tostring(accountSize), text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white, text_size= size.tiny)
        
        table.cell(table_id = riskCalculatorTable, column = 0, row = 3, text = "👻 Percent Risk:", text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white, text_size= size.tiny)
        table.cell(table_id = riskCalculatorTable, column = 1, row = 3, text = "👻 " + str.tostring(percentRisk) + "%" + " ($" + str.tostring(moneyToRiskPerTrade) + ")", text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white, text_size= size.tiny)

        table.cell(table_id = riskCalculatorTable, column = 0, row = 6, text = "📈 Lot size:", text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white, text_size= size.tiny)
        table.cell(table_id = riskCalculatorTable, column = 1, row = 6, text = "📈 " + str.tostring(Lot_Size  , "#.00"), text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white, text_size= size.tiny)
else if mobileDevice == "Desktop"
    var riskCalculatorTable = table.new(position = position.bottom_left, columns = 2, rows= 8, frame_color = color.black, frame_width = 4, border_width = 1, border_color = color.rgb(255, 0, 0, 100))
    if barstate.islast and showCalculator
        table.cell(table_id = riskCalculatorTable, column = 0, row = 0, text = "🦁🦁MM RISK CALCULATOR🦁🦁\n============================", bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white, text_halign=text.align_center)
        
        table.cell(table_id = riskCalculatorTable, column = 0, row = 1, text = "📊 ATR:", text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white)
        table.cell(table_id = riskCalculatorTable, column = 1, row = 1, text = "📊" + str.tostring(ATR, '#.0000'), text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white)
        
        table.cell(table_id = riskCalculatorTable, column = 0, row = 2, text = "💰 Account Size:", text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white)
        table.cell(table_id = riskCalculatorTable, column = 1, row = 2, text = "💰$" + str.tostring(accountSize), text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white)
        
        table.cell(table_id = riskCalculatorTable, column = 0, row = 3, text = "👻 Percent Risk:", text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white)
        table.cell(table_id = riskCalculatorTable, column = 1, row = 3, text = "👻 " + str.tostring(percentRisk) + "%" + " ($" + str.tostring(moneyToRiskPerTrade) + ")", text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white)
        
        table.cell(table_id = riskCalculatorTable, column = 0, row = 5, text = "📊 Stop-Loss in Pips:", text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white)
        table.cell(table_id = riskCalculatorTable, column = 1, row = 5, text = "📊 " + str.tostring(stoplossInPips  , "#.0"), text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white)
        
        table.cell(table_id = riskCalculatorTable, column = 0, row = 6, text = "📈 Lot size:", text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white)
        table.cell(table_id = riskCalculatorTable, column = 1, row = 6, text = "📈 " + str.tostring(Lot_Size  , "#.00"), text_halign = text.align_left, bgcolor = color.rgb(255, 0, 0, 100), text_color = color.white)